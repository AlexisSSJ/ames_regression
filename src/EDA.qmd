---
title: "EDA"                    
author: "Uriel Alexis Luna López"
format: 
    html :          
        code-fold: true
editor: visual                  
---

# Analisís de las variables

## Descripción de las variables

### Variables continuas y númericas

+-----------------------------+--------------------------------------------------------------------------------------+
| # Variable                  | Descrición                                                                           |
+=============================+:=====================================================================================+
| Lot_Frontage (Continua)     | Loguitud que conectan la calle con la propiedad (en pies)                            |
+-----------------------------+--------------------------------------------------------------------------------------+
| Lot Area (Continua)         | Tamaño del lote en pies cuadrados                                                    |
+-----------------------------+--------------------------------------------------------------------------------------+
| Mas Vnr Area (Continua)     | Área de revestimiento de mampostería en pies cuadrados                               |
+-----------------------------+--------------------------------------------------------------------------------------+
| BsmtFin SF 1 (Continua)     | Area del sótano terminada Tipo 1 en pies cuadrados                                   |
+-----------------------------+--------------------------------------------------------------------------------------+
| BsmtFin SF 2 (Continua)     | Area del sótano terminada Tipo 2 en pies cuadrados                                   |
+-----------------------------+--------------------------------------------------------------------------------------+
| Bsmt Unf SF (Continua)      | Área sin terminar del sótano en pies cuadrados                                       |
+-----------------------------+--------------------------------------------------------------------------------------+
| Total Bsmt SF (Continua)    | Área total del sótano                                                                |
+-----------------------------+--------------------------------------------------------------------------------------+
| 1st Flr SF (Continua)       | Pies cuadrqados del primer piso                                                      |
+-----------------------------+--------------------------------------------------------------------------------------+
| 2nd Flr SF (Continua)       | Pies cuadrados del segundo piso                                                      |
+-----------------------------+--------------------------------------------------------------------------------------+
| Low Qual Area SF (Continua) | Pies cuadrados terminados de baja calidad                                            |
+-----------------------------+--------------------------------------------------------------------------------------+
| Gr Liv Area (Continua)      | Superficie habitable sobre el nivel del suelo en pies cuadrados                      |
+-----------------------------+--------------------------------------------------------------------------------------+
| Wood Deck SF (Continua)     | Área de cubierta de madera en pies cuadrados                                         |
+-----------------------------+--------------------------------------------------------------------------------------+
| Open Porch SF (Continua)    | Área abierta del porche en pies cuadrados                                            |
+-----------------------------+--------------------------------------------------------------------------------------+
| Enclose Porch (Continua)    | Área cerrada del proche en pies cuadrados                                            |
+-----------------------------+--------------------------------------------------------------------------------------+
| 3-Ssn Porch (Continua)      | Área de porche de tres estaciones en pies cuadrados                                  |
+-----------------------------+--------------------------------------------------------------------------------------+
| Screen Porch (Continua)     | Área del porche cubierto en pies cuadrados                                           |
+-----------------------------+--------------------------------------------------------------------------------------+
| Pool Area (Continua)        | Área de la piscina en pies cuadrados                                                 |
+-----------------------------+--------------------------------------------------------------------------------------+
| Misc Val (Continua)         | Valor de la característica miscelanea                                                |
+-----------------------------+--------------------------------------------------------------------------------------+
| **Sale_Price (Continua)**   | Precio de venta.                                                                     |
+-----------------------------+--------------------------------------------------------------------------------------+
| Year Built (Discreta)       | Año original de construcción                                                         |
+-----------------------------+--------------------------------------------------------------------------------------+
| Year Remod/Add (Discreta)   | Fecha de remodelación (la misma que la fecha de construcción si no se ha remodelado) |
+-----------------------------+--------------------------------------------------------------------------------------+
| Bsmt Full Bath (Discreta)   | Baños completos en el sótano                                                         |
+-----------------------------+--------------------------------------------------------------------------------------+
| Bsmt Half Bath (Discreta)   | Medios baños en el sótano                                                            |
+-----------------------------+--------------------------------------------------------------------------------------+
| Full Bath (Discreta)        | Baños completos sobre el nivel del suelo                                             |
+-----------------------------+--------------------------------------------------------------------------------------+
| Half Bath (Discreta)        | Medios baños sobre el nivel del suelo                                                |
+-----------------------------+--------------------------------------------------------------------------------------+
| Kitchen (Discreta)          | Concinas sobre el nivel del suelo                                                    |
+-----------------------------+--------------------------------------------------------------------------------------+
| TotRmsAbvGrd                | Total de habitaciones sobre el nivel del suelo (no incluye baños)                    |
+-----------------------------+--------------------------------------------------------------------------------------+
| Fireplaces (Discreta)       | Número de chimeneas                                                                  |
+-----------------------------+--------------------------------------------------------------------------------------+
| Garage Yr Blt (Discreta)    | Año en que se construyó el garage                                                    |
+-----------------------------+--------------------------------------------------------------------------------------+
| Garage Cars (Discreta)      | Tamaño del garage en cuanto a capacidad para autos.                                  |
+-----------------------------+--------------------------------------------------------------------------------------+
| Mo Sold (Discreta)          | Mes de la venta (MM)                                                                 |
+-----------------------------+--------------------------------------------------------------------------------------+
| Yr Sold (Discreta)          | Año de la venta (YYYY)                                                               |
+-----------------------------+--------------------------------------------------------------------------------------+

### Varaibles categóricas

+--------------------------+----------------------------------------------------------------------------------------+
| Variable                 | Descrición                                                                             |
+==========================+========================================================================================+
| MS_Subclass (Nominal)    | Identifica el tipo de vivienda de la venta                                             |
+--------------------------+----------------------------------------------------------------------------------------+
| MS_Zoning (Nominal)      | Identifica la clasificación de la zona asociada a la venta                             |
+--------------------------+----------------------------------------------------------------------------------------+
| Street (Nominal)         | Tipo de camino de acceso a la propiedad                                                |
+--------------------------+----------------------------------------------------------------------------------------+
| Alley (Nominal)          | Tipo de callejón de acceso a la propiedad                                              |
+--------------------------+----------------------------------------------------------------------------------------+
| Lot Contour (Nominal)    | Planitud de la propiedad                                                               |
+--------------------------+----------------------------------------------------------------------------------------+
| Lot Config (Nominal)     | Configurarición del lote                                                               |
+--------------------------+----------------------------------------------------------------------------------------+
| Neightboorhood (Nominal) | Ubicación física dentro de los límites de la ciudad de Ames                            |
+--------------------------+----------------------------------------------------------------------------------------+
| Condition 1 (Nominal)    | Proximidad a varias condiciones                                                        |
+--------------------------+----------------------------------------------------------------------------------------+
| Condition 2 (Nominal)    | Proximidad a varias condiciones (Si más de una es presente)                            |
+--------------------------+----------------------------------------------------------------------------------------+
| Bldg Type (Nominal)      | Tipo de vivienda                                                                       |
+--------------------------+----------------------------------------------------------------------------------------+
| House Style (Nominal)    | Estilo de la vivienda                                                                  |
+--------------------------+----------------------------------------------------------------------------------------+
| Roof Style (Nominal)     | Tipo de techo                                                                          |
+--------------------------+----------------------------------------------------------------------------------------+
| Roof Matl (Nominal)      | Material del techo                                                                     |
+--------------------------+----------------------------------------------------------------------------------------+
| Exterior 1 (Nominal)     | Revestimiento exterior de la casa                                                      |
+--------------------------+----------------------------------------------------------------------------------------+
| Exterior 2 (Nominal)     | Revestimiento exterior de la casa (Si hay más de un material)                          |
+--------------------------+----------------------------------------------------------------------------------------+
| Mas Vnr Type (Nominal)   | Tipo de revestimiento de mampostería                                                   |
+--------------------------+----------------------------------------------------------------------------------------+
| Foundation (Nominal)     | Tipo de cimentación                                                                    |
+--------------------------+----------------------------------------------------------------------------------------+
| Heating (Nominal)        | Tipo de calefacción                                                                    |
+--------------------------+----------------------------------------------------------------------------------------+
| Central Air (Nominal)    | Aire acondicionado centralizado                                                        |
+--------------------------+----------------------------------------------------------------------------------------+
| Garage Type (Nominal)    | Ubicación del garage                                                                   |
+--------------------------+----------------------------------------------------------------------------------------+
| Misc Feature (Nominal)   | Característica miscelánea no cubierta en otras categorías                              |
+--------------------------+----------------------------------------------------------------------------------------+
| Sale Type (Nominal)      | Tipo de venta                                                                          |
+--------------------------+----------------------------------------------------------------------------------------+
| Sale Condition (Nominal) | Condicón de la venta.                                                                  |
+--------------------------+----------------------------------------------------------------------------------------+
| Functional (Ordinal)     | Funcionalidad del hogar (suponga que es típico a menos que se justifiquen deducciones) |
+--------------------------+----------------------------------------------------------------------------------------+
| FireplaceQu (Ordinal)    | Calidad de las chimeneas                                                               |
+--------------------------+----------------------------------------------------------------------------------------+
| Lot Shape (Ordinal)      | Forma general de la propiedad                                                          |
+--------------------------+----------------------------------------------------------------------------------------+
| Pool QC (Ordinal)        | Calidad de la piscina                                                                  |
+--------------------------+----------------------------------------------------------------------------------------+
| Utilities (Ordinal)      | Tipo de utilidades disponibles                                                         |
+--------------------------+----------------------------------------------------------------------------------------+
| Land Slope (Ordinal)     | Pendiente de la propiedad                                                              |
+--------------------------+----------------------------------------------------------------------------------------+
| Overall Qual (Ordinal)   | Califica el material general y el acabado de la casa.                                  |
+--------------------------+----------------------------------------------------------------------------------------+
| Overall Cond (Ordinal)   | Califica la condición general de la casa                                               |
+--------------------------+----------------------------------------------------------------------------------------+
| Exter Qual (Ordinal)     | Evalua la calidad materiales de los exteriores                                         |
+--------------------------+----------------------------------------------------------------------------------------+
| Exter Cond (Ordinal)     | Evalua la condición presente del materia en el exterior                                |
+--------------------------+----------------------------------------------------------------------------------------+
| Bsmt Qua (Ordinal)       | Evalua la altura del sótano                                                            |
+--------------------------+----------------------------------------------------------------------------------------+
| Bsmt Cond (Ordinal)      | Evalua la condición general del sótano                                                 |
+--------------------------+----------------------------------------------------------------------------------------+
| Bsmt Exposure (Ordinal)  | Se refiere a paredes a nivel de jardín o de salida                                     |
+--------------------------+----------------------------------------------------------------------------------------+
| BsmtFin Type 1 (Ordinal) | Calificación del area terminada del sótano                                             |
+--------------------------+----------------------------------------------------------------------------------------+
| BsmtFin Type 2 (Ordinal) | Clasificación del área terminada del sótano (si hay varios tipos)                      |
+--------------------------+----------------------------------------------------------------------------------------+
| Heating QC (Ordinal)     | Calidad y condición de la calefacción                                                  |
+--------------------------+----------------------------------------------------------------------------------------+
| Electrical (Ordinal)     | Sistema electrico                                                                      |
+--------------------------+----------------------------------------------------------------------------------------+
| Kitchen Qaul (Ordinal)   | Calidad de la cocina                                                                   |
+--------------------------+----------------------------------------------------------------------------------------+
| Garage Qual (Ordinal)    | Calidad del Garage                                                                     |
+--------------------------+----------------------------------------------------------------------------------------+
| Garage cond (Ordinal)    | Condicón del garage                                                                    |
+--------------------------+----------------------------------------------------------------------------------------+
| Paved Drive (Ordinal)    | Camino pavimentado.                                                                    |
+--------------------------+----------------------------------------------------------------------------------------+
| Garage Finish (Ordnal)   | El interior del garage esta terminado                                                  |
+--------------------------+----------------------------------------------------------------------------------------+
| Fence (Ordinal)          | Calidad de la cerca.                                                                   |
+--------------------------+----------------------------------------------------------------------------------------+

```{r}
#| label: startPy
#| include: false
library(reticulate)

use_virtualenv("CD_AMAT_2023")
```

```{python}
#| label: load-py-packages


import pandas as pd
from siuba import *
import numpy as np
from plotnine import *
from plydata.tidy import pivot_wider, pivot_longer
import matplotlib.pyplot as plt



from sklearn.model_selection import train_test_split
from sklearn.feature_selection import f_regression, mutual_info_regression
from plydata.one_table_verbs import pull

from mizani.formatters import comma_format, dollar_format


```

## Analísis de Sale Price

A continuación se muestra el split inicial

```{python}
#| label: intial_split
#| code-fold: false
#| echo: true

ames = (pd.read_excel( '../data/proyecto_ames_train.xlsx'  ).rename(columns = lambda x: x.replace (' ','_') )
                >> mutate (Price_4_GLA = _.SalePrice/_.Gr_Liv_Area))
ames.drop(index= 821, inplace=True)

y = ames >>  pull("Price_4_GLA")
X = select(ames, -_.SalePrice, -_.Price_4_GLA)


numeric_column = ames >> pull("Price_4_GLA")
quartiles = np.percentile(numeric_column, [25, 50, 75])

# Crea una nueva variable categórica basada en los cuartiles
stratify_variable = pd.cut(
 numeric_column, 
 bins=[float('-inf'), quartiles[0], quartiles[1], quartiles[2], float('inf')],
 labels=["Q1", "Q2", "Q3", "Q4"]
 )

ames_x_train, ames_x, ames_y_train, ames_y = train_test_split(
                       X, y, 
                       test_size = 0.30, 
                       random_state = 12345, 
                       stratify = stratify_variable
                       )


stratify_variable = pd.cut(
 ames_y , 
 bins=[float('-inf'), quartiles[0], quartiles[1], quartiles[2], float('inf')],
 labels=["Q1", "Q2", "Q3", "Q4"]
 )

ames_x_test, ames_x_val, ames_y_test, ames_y_val = train_test_split(
       ames_x, ames_y, 
       test_size = 0.5, 
       random_state = 12345, 
       stratify = stratify_variable
       )
       
Sale_Price_train= ames_y_train * np.array(ames_x_train.Gr_Liv_Area)
Sale_Price_test = ames_y_test * ames_x_test.Gr_Liv_Area
Sale_Price_validation = ames_y_val * ames_x_val.Gr_Liv_Area
print('Totales:\t', ames.shape[0],'\nTraining:\t', ames_y_train.shape[0],'\nTesting:\t', ames_y_test.shape[0],'\nValidation:\t', ames_y_val.shape[0])
```

```{python}
#| echo: false
summary = "count: 974\nmean: $180,757.27 \nstd: $80,744.88\nQ1: $129,062.5\nQ2:$160,000\nQ3: $213,099.75\nmin: $12,789\nmax:$755,000"
```

```{python}
#| results: hide
#| label: sale_price_dist
#| fig-keep: 'all'


(
  ggplot(aes(y=Sale_Price_train, x=0))+
                geom_violin( fill='#702C27',
                                style='right',
                                alpha=0.6)+
                geom_jitter(aes(x=np.zeros(974 )-0.21),
                            size=1,
                            alpha=0.4,
                            color='#006DC8',
                            width=0.2,
                            random_state=7)+
                geom_boxplot(aes(x=np.zeros(974 )-0.21),width=0.4,
                                    color='#182E40',
                                    alpha=0.1,
                                    outlier_alpha=1,
                                    outlier_color='#235C6C',
                                    outlier_size=1.5)+
                coord_flip()+
                theme_classic()+
                ggtitle('Distribución de los precios de venta')+
                scale_y_continuous(labels=dollar_format(big_mark=','))+
                ylab('Precio de venta')+
                annotate('text',x=0.3,y=500000, label=summary,ymax=400000)+
                geom_text(ha='left',label=summary, x=0.3, y=500000, size=10, fontweight=1)+
                theme(axis_ticks_minor_y=element_blank(),
                        axis_ticks_major_y=element_blank(),
                        axis_text_y=element_blank()
                        )+
                theme(figure_size=(8, 6))
)

```

```{python}
#| label: qqplot_Sale_Price
#| echo: false
#| results: hide

params={'loc':Sale_Price_train.mean(), 'scale':Sale_Price_train.std()}

(
                ggplot(aes(sample=Sale_Price_train))+
                geom_qq(alpha = 0.3,distribution='norm', dparams=params)+
                stat_qq_line(distribution='norm', dparams=params,color = "red")+
                scale_y_continuous(labels=dollar_format(big_mark=',', digits = 0)) + 
                scale_x_continuous(labels=dollar_format(big_mark=',', digits = 0)) + 
                xlab("Cuantilies de la dist. normal teórica") + ylab("Cuantiles de Sale Price") +
                ggtitle("QQ-Plot N~(mu=180,996.79, sd=81,186.69)")+
                theme_seaborn()
            
)
```

A diferencia de la distribución de los precios se venta de la casa, el precio por pie cuadrado habitable de la casa parece tener un comportamiento más normal:

```{python}
#| results: hide
#| label: sale_price_GLA_DIST 
#| fig-keep: 'all'
summary = "count: 974\nmean: $122.11\nstd: $32.60\nQ1: $100.69\nQ2:$120.64\nQ3: $141.27\nmin: $17.87\nmax:$276.25"
# plt.figure()
(
  ggplot(aes(y=ames_y_train, x=0))+
                geom_violin( fill='#702C27',
                                style='right',
                                alpha=0.6)+
                geom_jitter(aes(x=np.zeros(974 )-0.21),
                            size=1,
                            alpha=0.4,
                            color='#006DC8',
                            width=0.2,
                            random_state=7)+
                geom_boxplot(aes(x=np.zeros(974 )-0.21),width=0.4,
                                    color='#182E40',
                                    alpha=0.1,
                                    outlier_alpha=1,
                                    outlier_color='#235C6C',
                                    outlier_size=1.5)+
                coord_flip()+
                theme_classic()+
                ggtitle('Distribución de los precios de venta')+
                scale_y_continuous(labels=dollar_format(big_mark=','))+
                ylab('Precio de venta')+
                annotate('text',x=0.3,y=200, label=summary,ymax=200)+
                geom_text(ha='left',label=summary, x=0.3, y=500000, size=10, fontweight=1)+
                theme(axis_ticks_minor_y=element_blank(),
                        axis_ticks_major_y=element_blank(),
                        axis_text_y=element_blank()
                        )+
                theme(figure_size=(8, 6))
)

```

```{python}
#| results: hide
#| label: qq plot new y
#| fig-keep: 'all'
params={'loc':ames_y_train.mean(), 'scale':ames_y_train.std()}

(
                ggplot(aes(sample=ames_y_train))+
                geom_qq(alpha = 0.3,distribution='norm', dparams=params)+
                stat_qq_line(distribution='norm', dparams=params,color = "red")+
                scale_y_continuous(labels=dollar_format(big_mark=',', digits = 0)) + 
                scale_x_continuous(labels=dollar_format(big_mark=',', digits = 0)) + 
                xlab("Cuantilies de la dist. normal teórica") + ylab("Cuantiles de Sale Price") +
                ggtitle("QQ-Plot N~(mean=180,996.79, sd=81,186.69)")+
                theme_seaborn()
            
)
```

## Variables Continuas VS Transformación de Sale_Price

```{python}
#| label: corr_heatmap_HCC
#| results: hide
#| fig-keep: 'all'
continuas = [   'Lot_Frontage',
                'Lot_Area', 
                'Mas_Vnr_Area', 
                'Sale_Price/Gr_Liv_Area',
                'BsmtFin_SF_1', 
                'BsmtFin_SF_2', 
                'Bsmt_Unf_SF', 
                'Total_Bsmt_SF', 
                '1st_Flr_SF', 
                '2nd_Flr_SF', 
                # 'Low_Qual_Area_SF', 
                'Gr_Liv_Area', 
                'Wood_Deck_SF', 
                'Open_Porch_SF', 
                'Enclosed_Porch', 
                '3Ssn_Porch', 
                'Screen_Porch', 
                'Pool_Area', 
                'Misc_Val']
ames_train = ames_x_train.copy()
ames_train['Sale_Price/Gr_Liv_Area'] = ames_y_train
correlation_data = (
    ames_train[continuas].corr().melt(  ignore_index=False,
                                        var_name='var1').reset_index() >>
                    select( _.var1,
                            _.var2 == _.index,
                            _.cor == _.value  ) 
)


labels=(
    correlation_data >> case_when({_.cor.between(-0.3, 0.3):'',
                                    _.cor>0.99991: '',
                                    True :_.cor.round(2).astype(str)})
)

(
    correlation_data >>
        arrange(-_.cor,_.var1) >>
        # filter (_.var1!=_.var2) >>
        mutate(labb=labels)>>
        ggplot(aes(x='var1', y='var2', fill= 'cor'))+
        geom_tile()+
        geom_label(aes(label='labb'), size=6)+
        scale_fill_gradientn(colors=['#0092ff','#e6d6c7','#FF1400'],
                            limits=(-1,1),
                            name='Correlación')+
        ggtitle('Mapa de calor de correlaciones para variables continuas')+
        xlab('')+ylab('')+#guides(fill=guide_legend(title="New Legend Title"))+
        theme(axis_text_x=element_text(rotation=90,hjust = -1),
                figure_size=(8,6))
)


```

Como podemos observar para ser que las varaibles de `'BsmtFin_SF_1', '2nd_Flr_SF', 'Total_Bsmt_SF'` son las que tienen correlaciones más grandes con el precio de venta por el precio por pie cuadrado habitable. En el gráfico sólo se muestran etiquetas de correlaciones que no estan en el intervalo (-0.3.0.3).

```{python}
#| label: corr_sp/gla
#| results: hide
#| fig-keep: 'all'
(
    ames_train[continuas].corr().reset_index(drop=False) 
    >> select(_.spgl == _['Sale_Price/Gr_Liv_Area'],_.index)
    >> filter(_.spgl != 1)
    >> mutate (labels = np.round(_.spgl, 3))
    >> arrange(_.spgl)
    >> ggplot(aes(y='spgl', x='reorder(index,spgl)', fill='spgl'))
    + geom_col()
    + geom_text(aes(label = 'labels') , size=8, va='center', angle=90)
    + ylim([-0.5,0.5])
    + labs(title = 'Sale_Price/Gr_Liv_Area vs otras variables', y='', x='')
    + scale_fill_gradient2(low='#4EB043',
                           mid='#B05F43',
                           high= '#3A3AD5',
                           midpoint=0,
                           limits=(-1,1),
                           name='Correlación')
    + theme_bw()
    + theme(axis_text_x=element_text(angle=90))
)
```

## Precios dependiendo la ubicación

```{python}
#| label: error_bars por vecindario
#| results: hide
#| fig-keep: 'all'
(
  ames_train 
        >> group_by(_.Neighborhood) 
        >> summarize(media = np.mean(_['Sale_Price/Gr_Liv_Area']), desv=np.std(_['Sale_Price/Gr_Liv_Area']))
        >> mutate( max_err = _.media  + _.desv, min_err =  _.media  - _.desv)
        >> arrange(_.media)
        >> ggplot(aes(x='reorder(Neighborhood,media)', y='media') ) 
        + geom_errorbar(aes(ymin='min_err', ymax='max_err'),width=0.3, position=position_dodge(0.9))+geom_point()
        + theme_bw()
        + theme(axis_text_x=element_text(angle=90))
        + scale_y_continuous(labels=dollar_format(big_mark=',', digits = 0)) 
        +coord_flip()
        +labs(y='Precio  promedio por pie cuadrado de área habitable', x='')
)
```

## Variables relacionadas con el sótano

Se puede ver que se tiene una relación líneal creciente entre `Total_Bsmt_SF` y `Sale_Price\ Gr_Liv_Area`, en la siguiente gráfica tambien podemos ver como varios puntos se acumulan en `Total_Bsmt_SF = 0` debido a que estas casas no cuentan con sótano

```{python}
#| label: price vs sf sotano
#| results: hide
#| fig-keep: 'all'
(
    ames_x_train 
        >> ggplot( aes(y=ames_y_train, x= 'Total_Bsmt_SF'))
        + geom_point(size=1,alpha=0.4)
        + geom_smooth(color='red')
        + scale_y_continuous(labels = dollar_format(digits=0, big_mark=',') )
        +xlim([0,2500])
        + labs(title = 'Total_Bsmt_SF vs  Sale Price/ Gr_Liv_Area', x='Total_Bsmt_SF', y='Sale Price/ Gr_Liv_Area')
        + theme_538()
)
```

En cuanto a las variables categóricas relacionadas al sótano encontramos lo siguiente:

```{python}
#| label: analisis sotano
#| results: hide
#| fig-keep: 'all'
cat_columns = pd.Series(['Bldg_Type', 
            'Bsmt_Exposure', 
            'Central_Air', 
            'Condition_1', 
            'Condition_2', 
            'Electrical', 
            'Fence', 
            'Foundation', 
            'Garage_Finish', 
            'Garage_Type', 
            'Misc_Feature', 
            'Paved_Drive', 
            'Heating_QC',
            'Overall_Cond',
            'MS_SubClass', 
            'MS_Zoning',
            'Bsmt_Cond',
            'BsmtFin_Type_1', 
            'BsmtFin_Type_2',
            'House_Style',
            'Lot_Shape',
            'Neighborhood'])
for category in cat_columns[cat_columns.str.contains('Bsmt')]:
  titulo='Categoría analazada: {}'.format(category) 
  (ames_train  >> ggplot(aes(y= 'Sale_Price/Gr_Liv_Area', x= 'Total_Bsmt_SF', color= '{}'.format(category)))
              + geom_point(alpha= 0.5, show_legend=False) + geom_smooth(color='black', method = 'lm')
              +xlim([0,3000])
              +labs(x='Área total del sótano', y='Precio por pie cuadrado de área habitable bruta', title=titulo)
              + facet_wrap('~{}'.format(category))+theme_538 ()) +theme_minimal()
```

Puntos a considerar:

-   En `Bsmt_Exposure` se puede notar que la relación positiva entre las variables se mantiene, y no parece cambiar si se altera la exposicón del sótano. Además se muestran elementos con `Total_Bmst_SF`\>0 que caen en la categoría de No basement, lo cual puede deberse a un error.

-   En `Bsmt_Cond` se puede ver que la relación de las variables si cambia dependiendo de la condición del sótano, además en la condición de Excellent y Poor se tienen muy pocas observaciones.

-   En `Bsmt_Type_1` se tienen relaciones demaciado planas en su mayoria, a excepción de GLQ y Unf.

-   En `Bsmt_Type_2` se tiene el mismo caso que en el anterior. Además se muestran elementos con `Total_Bmst_SF`\>0 que caen en la categoría de No basement, lo cual puede deberse a un error.

# Fuciones personalizadas

```{python}
#| label: libraries lm
#| results: hide
#| code-fold: false

from sklearn.preprocessing import StandardScaler, OneHotEncoder,FunctionTransformer
from sklearn.linear_model import LinearRegression
from sklearn.pipeline import Pipeline
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error
from sklearn.metrics import mean_squared_error, r2_score, make_scorer
from sklearn.model_selection import train_test_split, KFold, cross_val_score, cross_validate
import statsmodels.api as sm
pd.options.display.float_format = '{:.4f}'.format

```

```{python}
#| label: custom_fucntions
#| results: hide
#| code-fold: false

def importance_from_model (test_frame, y_obs, selected_columns, pipeline, actual_mse, n_permutations=50 ,trans_pred= False ):
  performance_losses = []
  
  for i in range(test_frame[selected_columns].shape[1]):
    loss = []
    for j in range(n_permutations):
        test_frame_permuted = test_frame[selected_columns].copy()
        test_frame_permuted.iloc[:, i] = np.random.permutation(test_frame_permuted.iloc[:, i])
        if trans_pred == False:
            y_pred_permuted = pipeline.predict(test_frame_permuted)
        else:
            y_pred_permuted = pipeline.predict(test_frame_permuted)* test_frame_permuted.Gr_Liv_Area
        mse_permuted = mean_squared_error(y_obs, y_pred_permuted)
        loss.append(mse_permuted)
    performance_losses.append(loss)
  
  performance_losses = performance_losses/np.sum(performance_losses, axis=0)
  mean_losses = np.mean(performance_losses, axis=1)
  std_losses = np.std(performance_losses, axis=1)
  
  importance_df = pd.DataFrame({
  'Variable': selected_columns, 
  'Mean_Loss': mean_losses, 
  'Std_Loss': std_losses
  })
  return importance_df
  

def adjusted_r2_score(y_true, y_pred, n, p):
  r2 = r2_score(y_true, y_pred)
  adjusted_r2 = 1 - (1 - r2) * (n - 1) / (n - p - 1)
  return adjusted_r2




def div_columns(X, c1, c2):
    X["c1_c2"] = X[c1]/ X[c2]
    return X



def adj_r(y_o, y_p , p, n):
  r2_adj = 1 - (n - 1) / (n - p - 1) * (1 - r2_score(y_o, y_p))
  
  
def get_metrics (y_pred, y_obs,predictors):
  me = np.mean(y_obs - y_pred)
  mae = mean_absolute_error(y_obs, y_pred)
  mape = mean_absolute_percentage_error(y_obs, y_pred)
  mse = mean_squared_error(y_obs, y_pred)
  rmse = np.sqrt(mse)
  r2 = r2_score(y_obs, y_pred)

  n = len(y_obs)  # Número de observaciones
  p = predictors  # Número de predictores 
  r2_adj = 1 - (n - 1) / (n - p - 1) * (1 - r2)
  

  metrics_data = {
      "Metric": ["ME", "MAE", "MAPE", "MSE", "RMSE", "R2", "R2Adj"],
      "Value": [me, mae, mape, mse, rmse, r2, r2_adj]
  }
  return pd.DataFrame(metrics_data).set_index('Metric')



def rmv_elements (list_of_elements, complete_list):
  for element in list_of_elements:
    complete_list.remove(element)
  return complete_list



def validation_results(x_val,y_val,  pipeline , n_preds):
  y_pred = pipeline.predict(x_val)
  
  ames_test = (
    ames_x_val >>
    mutate(Sale_Price_Pred = y_pred, Sale_Price =y_val))
  
  ##### Métricas de desempeño
  
  y_obs = ames_test["Sale_Price"]
  y_pred = ames_test["Sale_Price_Pred"]
  return get_metrics(y_pred, y_obs, n_preds)


def intersection(lst1, lst2):
    lst3 = [value for value in lst1 if value in lst2]
    return lst3


def check_cv (df, param_p = False):
  if param_p == False:
    (df 
      >> mutate(RMSE = abs(_.mean_test_neg_mean_squared_error)**0.5, MAPE = abs (_.mean_test_mape))
      >> pivot_longer(
                      cols=['mean_test_r2', 'MAPE','RMSE'],
                      names_to='parameter', 
                      values_to='value')
      >> ggplot( aes(x = "param_n_neighbors", y = "value", shape = "param_weights", color= 'param_metric')) 
      + geom_point(alpha = 0.9,position=position_dodge(width=0.1))
      + facet_wrap("~parameter",ncol =1, scales = "free_y")
      + labs( y = '',x= 'Parámetro: vecinos cercanos K' ,shape = 'Ponderación',color = 'Métrica' )).draw(True)
  else:
    (df 
      >> mutate(RMSE = abs(_.mean_test_neg_mean_squared_error)**0.5 , MAPE = abs (_.mean_test_mape))
      >> pivot_longer(
                      cols=['mean_test_r2', 'MAPE','RMSE'],
                      names_to='parameter', 
                      values_to='value')
      >> ggplot( aes(x = "param_n_neighbors", y = "value", shape = "param_weights", color= 'param_metric',size = 'param_p')) 
      + geom_point(alpha = 0.9,position=position_dodge(width=0.1))
      + facet_wrap("~parameter",ncol =1, scales = "free_y")
      + labs( y = '',x= 'Parámetro: vecinos cercanos K' ,shape = 'Ponderación',color = 'Métrica' )).draw(True)


def div_columns(X, c1, c2, feature_name ):
    name = feature_name+'_c_'
    X[c1] = X[c1].astype(float)
    X[c2] = X[c2].astype(float)
    X[name] = X[c1]/ X[c2]
    return X[[name]]


def div_columns2(X, c1, c2, feature_name ):
    name = feature_name+'_c_'
    X[c1] = X[c1].astype(float)
    X[c2] = X[c2].astype(float)
    X[name] = X[c1]/ X[c2]
    return X[[name]].fillna(0)

def collapse(X, c1, dic):
  return X[[c1]].replace(dic)

def cross_interactions (X, num, cat, return_inputs = 'none'):
    return_cols = []
    df = X.filter(regex=(cat)).copy()
    for column in df.columns.to_list():
      name = column + '_x_'+ num
      X[name] = df[column] * X[num]
      return_cols.append(name)
    if return_inputs == 'none':
      return X[return_cols]
    elif return_inputs == 'both':
      return X[return_cols + df.columns.to_list() + [num]]
    elif return_inputs == 'num':
      return X[return_cols + [num]]
    else:
      return X[return_cols+ df.columns.to_list()]

def cross_interactions2 (X, num, cat, return_inputs = 'none'):
    return_cols = []
    df = X.filter(regex=(cat)).copy()
    df2 = X.filter(regex=(num)).copy()
    for col_num in df2.columns.to_list():
      for column in df.columns.to_list():
        name = column + '_x_'+ col_num
        X[name] = df[column] * X[col_num]
        return_cols.append(name)
    if return_inputs == 'none':
      return X[return_cols]
    elif return_inputs == 'both':
      return X[return_cols + df.columns.to_list() + df2.columns.to_list()]
    elif return_inputs == 'num':
      return X[return_cols + df2.columns.to_list()]
    else:
      return X[return_cols+ df.columns.to_list()]

def antique_func(X,yb, yr):
  return (X >> mutate (Antique_c_ = 2023 - _[yb], Last_remod_c_ = 2023 - _[yr], Antique2_c_=(2023 - _[yb])**2)
          >> select (_.contains ('_c_')))



```

# Regresión Líneal

## Preparación de los datos

En la documentación del dataset podemos encontrar información útil para saber como imputar los NA's , se creó un `ColumnTransformer()` con el nombre de `clean_and_imputer`, este transformador hace lo siguiente:

-   Elimina columnas que potencialmente podría provocar data leakage o son poco informativas.

-   Imputación de NA's de variables categorias y númericas de acuerdo a la documentación de los datos.

```{python}
#| label: data_clean_lm
#| code-fold: false
#| results: hide 
from sklearn.compose import make_column_selector
from sklearn.compose import ColumnTransformer
from sklearn.impute import SimpleImputer



n_usefull = ['Sale_Type', 'Sale_Condition', 'Pool_QC', 'Pool_Area', 'Yr_Sold']

# NA de Alley are no_alley ACCES
# na de Mas_Vnr_Type es none
# NA EN Bsmt_Qual es No_basement
#remember quit "No_Basement" cat
# electrical imput mode
# no fire place imput 'No_Fireplace'

clean_and_imputers = ColumnTransformer(
    [('not_usefull_variables', 'drop', n_usefull),
     ('Impute_Alley', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 'No_Alley_Access'), ['Alley']),
     ('Impute_Mas_Vnr_Type', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 'None'), ['Mas_Vnr_Type']),
     ('Impute_Mas_Vnr_Area', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 0), ['Mas_Vnr_Area']),
     ('Impute_Lot_Frontage', SimpleImputer(
         missing_values=np.nan,
         strategy='mean'), ['Lot_Frontage']),
     ('Impute_Fireplace_Qu', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 'No_Fireplace'), ['Fireplace_Qu']),
     ('Impute_Electrical', SimpleImputer(
         missing_values=np.nan,
         strategy='most_frequent'),['Electrical']),
     ('Impute_Bsmt_Cat', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 'No_Basement'), make_column_selector(pattern = 'Bsmt',dtype_include = 'object')),
     ('Impute_Bsmt_Numeric', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 0), make_column_selector(pattern = 'Bsmt',dtype_exclude = 'object')),
     ('Impute_Garage', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 'No_Garage'), make_column_selector(pattern = 'Garage',dtype_include = 'object')),
     ('Impute_Garage_numeric', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 0), make_column_selector(pattern = 'Garage',dtype_exclude = 'object')),
     ('Impute_Fence', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 'No_Fence'), ['Fence']),
     ('Impute_Misc_Feature', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 'None'), ['Misc_Feature'])
    ],
    remainder= 'passthrough',
    verbose_feature_names_out = False
).set_output(transform = 'pandas')

clean_ames_x_train = clean_and_imputers.fit_transform(ames_x_train)
```

## Feature Engineering

En este `ColumnTransformer()` se crean diferentes variables o se módifican algunas otras, en resumen el siguente transformador hace lo siguiente:

-   Se crean 11 variables que en su mayoría se refieren a proporciones.

-   Se colapsan las columnas de las variables `Overall_Cond` y `Overall_Qual`.

-   Todas estas transformaciones fueron hechas con `FunctionTransformer()` utilizando funciones creadas de manera propia que se encuentran en el apartado de **Funciones personalizadas**

```{python}
#| label: feature_eng_lm
#| code-fold: false
#| results: hide
cond ={1: 'Poor', 2:'Poor',3:'Poor',4:'Average', 5:'Average',6:'Average', 7:'Good_or_Excellent', 8:'Good_or_Excellent', 9:'Good_or_Excellent', 10 :'Good_or_Excellent'}

feature_eng = ColumnTransformer(
  [('collapse_cond',  FunctionTransformer(
                                 collapse,
                                 feature_names_out = None,
                                 kw_args={'c1': 'Overall_Cond', 'dic' : cond }
                                 ), ['Overall_Cond']),
  ('collapse_cond2',  FunctionTransformer(
                                 collapse,
                                 feature_names_out = None,
                                 kw_args={'c1': 'Overall_Qual', 'dic' : cond }
                                 ), ['Overall_Qual']),
  ('Area_Per_Room',  FunctionTransformer(
                                 div_columns,
                                 feature_names_out = None,
                                 kw_args={'c2': 'TotRms_AbvGrd', 'c1': 'Gr_Liv_Area', 'feature_name' : 'Area_Per_Room'}
                                 ), ['TotRms_AbvGrd', 'Gr_Liv_Area']),
    ('Wood_propGLA',  FunctionTransformer(
                                 div_columns,
                                 feature_names_out = None,
                                 kw_args={'c1': 'Wood_Deck_SF', 'c2': 'Gr_Liv_Area', 'feature_name' : 'Wood_propGLA'}
                                 ), ['Wood_Deck_SF', 'Gr_Liv_Area']),
    ('MVNRA_prop',  FunctionTransformer(
                                 div_columns,
                                 feature_names_out = None,
                                 kw_args={'c1': 'Mas_Vnr_Area', 'c2': 'Lot_Area', 'feature_name' : 'MVNRA_propLA'}
                                 ), ['Mas_Vnr_Area', 'Lot_Area']),
    ('2nd_Flr_SF_propGLA',  FunctionTransformer(
                                 div_columns,
                                 feature_names_out = None,
                                 kw_args={'c1': '2nd_Flr_SF', 'c2': 'Gr_Liv_Area', 'feature_name' : '2nd_Flr_SF_propGLA'}
                                 ), ['2nd_Flr_SF', 'Gr_Liv_Area']),
    ('Bsmt_Prop',  FunctionTransformer(
                                 div_columns,
                                 feature_names_out = None,
                                 kw_args={'c1': 'Total_Bsmt_SF', 'c2': 'Gr_Liv_Area', 'feature_name' : 'Bsmt_Prop'}
                                 ),['Total_Bsmt_SF', 'Gr_Liv_Area'] ),
    ('Time_var',  FunctionTransformer(
                                 antique_func,
                                 feature_names_out = None,
                                 kw_args={'yb': 'Year_Built', 'yr': 'Year_Remod/Add'}
                                 ), ['Year_Built', 'Year_Remod/Add']),
    ('Gr_Liv_Area / Loot_Area',  FunctionTransformer(
                                 div_columns,
                                 feature_names_out = None,
                                 kw_args={'c1': 'Gr_Liv_Area', 'c2': 'Lot_Area', 'feature_name' : 'Gr_Liv_A/Loot_A'}
                                 ),['Gr_Liv_Area', 'Lot_Area'] ),
    ('Garage_Prop_overGLA',  FunctionTransformer(
                                 div_columns,
                                 feature_names_out = None,
                                 kw_args={'c1': 'Garage_Area', 'c2': 'Gr_Liv_Area', 'feature_name' : 'Garage_Prop_overGLA'}
                                 ),['Garage_Area', 'Gr_Liv_Area'] ),
    ('1s_Floor_prop',  FunctionTransformer(
                                 div_columns,
                                 feature_names_out = None,
                                 kw_args={'c1': '1st_Flr_SF', 'c2': 'Gr_Liv_Area', 'feature_name' : '1s_Floor_prop'}
                                 ),['1st_Flr_SF', 'Gr_Liv_Area'] ),
    ('just_select', 'passthrough', ['Total_Bsmt_SF','2nd_Flr_SF', 'TotRms_AbvGrd', '1st_Flr_SF', 'Year_Built', 'Year_Remod/Add', 'Garage_Area', 'Lot_Area', 'Gr_Liv_Area', 'Mas_Vnr_Area','Wood_Deck_SF' ])],
    verbose_feature_names_out = False,
    remainder = 'passthrough').set_output(transform = 'pandas')


feature_eng_df = feature_eng.fit_transform(clean_ames_x_train)
my_features = (feature_eng_df>> select (_.contains('_c_'))).columns.to_list()
```

## Preprocesado de los datos

Una vez se limpiaron los datos y se crearon variables, se define el preprocesado para hacer el One Hot Encoding y la estandarización de variables seleccionadas, `preprocesor_1` es un transformador que estandariza algunas variables númericas y aplica `OneHotEncoder()` a todas las variables del tipo `Object`, colapsando categorias que tienen menos de 12 datos.

```{python}
#| label: preprocesado1_lm
#| code-fold: false
#| results: hide
num_cols =['Wood_Deck_SF',
            '1st_Flr_SF',
            'Open_Porch_SF',
            'Enclosed_Porch',
            'Lot_Area',
            'Total_Bsmt_SF',
            'Garage_Area',
            'Gr_Liv_Area',
            'Bsmt_Full_Bath',
            '3Ssn_Porch',
            'BsmtFin_SF_1',
            'BsmtFin_SF_2',
            'Bsmt_Unf_SF',
            'Bsmt_Half_Bath',
            'Kitchen_AbvGr',
            'Mas_Vnr_Area',
            'Misc_Val',
            'Lot_Frontage',
            'Bedroom_AbvGr']

preprocessor_1 = ColumnTransformer(
    transformers = [
        ('scaler', StandardScaler(), num_cols),
        ('just_select', 'passthrough', my_features ),
        ('OHE', OneHotEncoder(drop='first',handle_unknown='infrequent_if_exist' , sparse_output=False, min_frequency = 12), make_column_selector(dtype_include  = 'object'))],
    verbose_feature_names_out = False,
    remainder = 'passthrough').set_output(transform = 'pandas')


prep_df = preprocessor_1.fit_transform(feature_eng_df)
```

## Resultados preeliminares del modelo líneal

A continuación se muestran las métricas de test con el full model

```{python}
#| label: resultados_fullmodel_lm
#| code-fold: false
#| results: hide
lm_pre = Pipeline([
  ('clean_data', clean_and_imputers),
  ('feat_eng', feature_eng),
  ('preprocessor', preprocessor_1),
  ('regressor', LinearRegression())])
 
lm_pre.fit(ames_x_train, ames_y_train)

y_pred = lm_pre.predict(ames_x_test) * ames_x_test.Gr_Liv_Area
y_obs = Sale_Price_test

predictores = prep_df.shape[1]
```

*Métrcias de desempeño del full-model*

```{python}
#| label: resultados fm lm
#| output: asis
#| echo: false
get_metrics(y_pred, y_obs, predictores).to_html()
```

## Mejora del modelo

Se crearon dos transformadores adicionales; `interactions`, el cual crea intercaciones entre diferentes variables y `step_rm` el cual elimina columnas que no aportan al modelo antes de aplicar la regresión.

Durante este proceso se fueron creando diferentes interacciones y se removieron variables tomando en cuenta los contrastes de hipotesis del modelo, se dejaron las interacciones que mostraron mejores resultados, al igual que las variables que se decidieron remover para buscar el modelo más parsimonioso.

```{python}
#| label: interactions_lm
#| code-fold: false
#| results: hide
interactions = ColumnTransformer(
  [('Garage_interaction', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': 'Garage_Prop_overGLA_c_', 'cat': 'Garage_Qual', 'return_inputs':'both'}
                                 ), make_column_selector ('Garage_Qual|Garage_Prop_overGLA_c_')),
  ('inter_kitchen', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': 'Kitchen_AbvGr', 'cat': 'Kitchen_Qual', 'return_inputs':'both'}
                                 ), make_column_selector ('Kitchen_Qual|Kitchen_AbvGr')),
  ('Last_remod_c_', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': 'Gr_Liv_A/Loot_A_c_', 'cat': 'Gr_Liv_A/Loot_A_c_', 'return_inputs':'num'}
                                 ), make_column_selector ('Gr_Liv_A/Loot_A_c_')),
  ('1s_Floor_prop_c_|Overall_Q', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': '1s_Floor_prop_c_', 'cat': 'Overall_Q', 'return_inputs':'both'}
                                 ), make_column_selector ('1s_Floor_prop_c_|Overall_Q')),
  ('Bsmt_Qual|Bsmt_Prop_c_', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': 'Bsmt_Prop_c_', 'cat': 'Bsmt_Qual', 'return_inputs':'both'}
                                 ), make_column_selector ('Bsmt_Qual|Bsmt_Prop_c_')),
  ('Area_Per_Room_c_|Overall', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': '2nd_Flr_SF_propGLA_c_', 'cat': 'Antique', 'return_inputs':'both'}
                                 ), make_column_selector ('2nd_Flr_SF_propGLA_c_|Antique')),
  ('MVNRA_propGLA_c_|Mas_Vnr_Type', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': 'MVNRA_propLA_c_', 'cat': 'Mas_Vnr_Type', 'return_inputs':'both'}
                                 ), make_column_selector ('MVNRA_propLA_c_|Mas_Vnr_Type')),
  ('Wood_propGLA_c_|Fireplaces', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': 'Wood_propGLA_c_', 'cat': 'Fireplaces', 'return_inputs':'both'}
                                 ), make_column_selector ('Wood_propGLA_c_|Fireplaces')),
  ('Wood_propGLA_c_|Antique', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': 'Gr_Liv_Area', 'cat': 'Neighborhood', 'return_inputs':'both'}
                                 ), make_column_selector ('Gr_Liv_Area|Neighborhood_C|Neighborhood_[STN]')),
  ('TO_DROP_', 'drop', make_column_selector('No_Basement|No_Garage|Exterior|Land|Fence')) ],
  verbose_feature_names_out = False,
  remainder='passthrough').set_output(transform = 'pandas')
```

```{python}
#| label: step_remove_lm
#| code-fold: false
#| results: hide
drop_cols=['2nd_Flr_SF',
		'3Ssn_Porch',
		'Neighborhood_IDOTRR',
		'Kitchen_Qual_Gd',
		'Alley_No_Alley_Access',
		'Neighborhood_StoneBr_x_Gr_Liv_Area',
		'BsmtFin_SF_1',
		'Alley_Pave',
		'Neighborhood_BrkSide',
		'Neighborhood_SawyerW_x_Gr_Liv_Area',
		# 'Neighborhood_SawyerW'
		'Neighborhood_Edwards',
		'Bedroom_AbvGr',
		'Kitchen_Qual_Fa',
		'Bldg_Type_2fmCon',
		'Neighborhood_Timber_x_Gr_Liv_Area',
		'Neighborhood_Timber',
		'Neighborhood_NWAmes_x_Gr_Liv_Area',
		'Neighborhood_Somerst_x_Gr_Liv_Area',
		'Bldg_Type_Duplex','Condition_1_infrequent_sklearn',
		# 'Neighborhood_MeadowV_x_Gr_Liv_Area',
		'Roof_Style_infrequent_sklearn',
		'Bldg_Type_Twnhs',
		'Bldg_Type_TwnhsE',
		'BsmtFin_SF_2',
		'BsmtFin_Type_1_BLQ',
		'BsmtFin_Type_1_GLQ',
		'Neighborhood_SWISU_x_Gr_Liv_Area',
		'Mas_Vnr_Type_None_x_MVNRA_propLA_c_',
		# 'Bsmt_Qual_Fa',
		'Neighborhood_ClearCr',
		'BsmtFin_Type_1_LwQ',
		'BsmtFin_Type_1_Rec',
		'Kitchen_Qual_TA',
		# 'TotRms_AbvGrd',
		'BsmtFin_Type_1_Unf',
		'BsmtFin_Type_2_BLQ',
		'BsmtFin_Type_2_GLQ',
		'BsmtFin_Type_2_LwQ','Neighborhood_CollgCr_x_Gr_Liv_Area',
		# '1st_Flr_SF',
		# 'Mas_Vnr_Type_None_x_MVNRA_propGLA_c_',
		# 'Mas_Vnr_Type_Stone_x_MVNRA_propGLA_c_',
		'BsmtFin_Type_2_Rec',
		# 'Neighborhood_Mitchel_x_Gr_Liv_Area',
		# 'Mas_Vnr_Type_infrequent_sklearn_x_MVNRA_propGLA_c_',
		'BsmtFin_Type_2_Unf',
		'Kitchen_Qual_TA_x_Kitchen_AbvGr',
		'Bsmt_Cond_Gd',
		'Fireplace_Qu_Po',
		'Bsmt_Cond_TA',
		'Bsmt_Cond_infrequent_sklearn',
		'Bsmt_Exposure_Mn',
		'Bsmt_Exposure_No',
		'Foundation_PConc',
		# 'Heating_QC_Fa',
		# 'Functional_infrequent_sklearn',
		# 'Mas_Vnr_Type_infrequent_sklearn',
		'Bsmt_Full_Bath',
		'Bsmt_Half_Bath',
		# 'Bsmt_Qual_Fa',
		# 'Condition_1_Norm',
		'Bsmt_Qual_Gd_x_Bsmt_Prop_c_',
		# 'Exter_Qual_TA',
		# 'Exter_Qual_Gd',
		# 'Exter_Qual_Fa',
		'Bsmt_Qual_No_Basement',
		'Bsmt_Qual_No_Basement_x_Bsmt_Prop_c_',
		'Mas_Vnr_Type_infrequent_sklearn_x_MVNRA_propLA_c_',
		'Bsmt_Qual_TA_x_Bsmt_Prop_c_',
		'Bsmt_Unf_SF',
		# 'Neighborhood_MeadowV',
		'Overall_Cond_Good_or_Excellent',
		'Central_Air_Y',
		'Condition_1_Feedr',
		'Condition_2_infrequent_sklearn',
		'Overall_Cond_Poor',
		# 'Fireplaces'
		# '1st_Flr_SF',
		# 'Functional_Typ',
		'Electrical_FuseF',
		'Electrical_SBrkr',
		'Electrical_infrequent_sklearn',
		# 'Mas_Vnr_Type_infrequent_sklearn',
		# 'Mas_Vnr_Type_None',
		'Enclosed_Porch',
		'Exter_Cond_Gd',
		'Exter_Cond_TA',
		'Fireplace_Qu_infrequent_sklearn',
		'Foundation_CBlock',
		'Foundation_Slab',
		'Foundation_infrequent_sklearn',
		'Full_Bath',
		'Functional_Min2',
		'Garage_Cars',
		'Garage_Cond_TA',
		'Garage_Cond_infrequent_sklearn',
		'Garage_Finish_RFn',
		'Garage_Finish_Unf',
		'Garage_Qual_No_Garage',
		'Garage_Qual_No_Garage_x_Garage_Prop_overGLA_c_',
		'Garage_Qual_infrequent_sklearn',
		'Garage_Qual_infrequent_sklearn_x_Garage_Prop_overGLA_c_',
		'Garage_Type_BuiltIn',
		'Garage_Type_Detchd',
		'Garage_Type_infrequent_sklearn',
		'Garage_Yr_Blt',
		'Half_Bath',
		'Heating_QC_Gd',
		'Heating_QC_infrequent_sklearn',
		'Heating_infrequent_sklearn',
		'House_Style_1Story',
		'House_Style_2Story',
		'House_Style_SFoyer',
		'House_Style_SLvl',
		'House_Style_infrequent_sklearn',
		'Kitchen_Qual_infrequent_sklearn',
		'Kitchen_Qual_infrequent_sklearn_x_Kitchen_AbvGr',
		'Last_remod_c_',
		'Lot_Area',
		'Lot_Config_CulDSac',
		'Lot_Config_FR2',
		'Lot_Config_Inside',
		'Lot_Config_infrequent_sklearn',
		'Lot_Frontage',
		'Lot_Shape_IR2',
		'Lot_Shape_Reg',
		'Lot_Shape_infrequent_sklearn',
		'Low_Qual_Fin_SF',
		'MS_SubClass',
		'MS_Zoning_RL',
		'MS_Zoning_RM',
		'MS_Zoning_infrequent_sklearn',
		'Mas_Vnr_Area',
		'Misc_Feature_Shed',
		'Mo_Sold',
		'Neighborhood_Crawfor',
		'Neighborhood_NoRidge',
		'Neighborhood_NridgHt',
		'Neighborhood_Somerst',
		'Neighborhood_infrequent_sklearn',
		'Open_Porch_SF',
		'Overall_Qual_Poor_x_1s_Floor_prop_c_',
		'Paved_Drive_P',
		'Paved_Drive_Y',
		'Roof_Style_Hip',
		'Roof_Matl_infrequent_sklearn',
		# 'Functional_infrequent_sklearn',
		'Wood_Deck_SF',
		'Garage_Area','Kitchen_Qual_Gd_x_Kitchen_AbvGr',
		'Screen_Porch',
		'Street_infrequent_sklearn',
		'Total_Bsmt_SF',
		'Garage_Qual_TA',
		'Kitchen_Qual_Fa_x_Kitchen_AbvGr',
		'Utilities_infrequent_sklearn'
		#############removing sf
            ]

step_rm =ColumnTransformer(
  [('TO_DROP', 'drop', drop_cols )],
  verbose_feature_names_out = False,
  remainder='passthrough').set_output(transform = 'pandas')
```

## Creación del pipiline final y analísis de resultados

```{python}
#| label: final_pipeline_lm
#| code-fold: false
#| results: hide
pipeline_linreg = Pipeline([
  ('clean_data', clean_and_imputers),
  ('feat_eng', feature_eng),
  ('preprocessor', preprocessor_1),
  ('interactions', interactions),
  ('remove', step_rm),
  ('regressor', LinearRegression())])

pipeline_linreg.fit(ames_x_train, ames_y_train)

transformed_df = step_rm.fit_transform(interactions.fit_transform(prep_df))
```

A continuaci'on se muestra el resumen de ajuste:

```{python}
#| label: Extracción de coeficientes
#| code-fold: false
coefs = pd.DataFrame({
  'variable':transformed_df.columns.to_list(),
  'coefs': pipeline_linreg.named_steps['regressor'].coef_.round(5)
  })


model = sm.OLS(ames_y_train, sm.add_constant(transformed_df) ).fit()

conf_int  = model.conf_int().reset_index().rename(columns ={'index': 'variable', 0:"min", 1: 'max'})

p_vals = (
        model.pvalues.reset_index()
        >> select( _.variable == _.index, _.p_val == -1)
        >> mutate (s = case_when({
              _.p_val<0.025:'***',
              _.p_val<0.05:'**',
              _.p_val<0.1:'*',
              True:''}))
        >> arrange (_.s,- _.p_val)
        >>left_join(_, coefs, on = 'variable')
        >> left_join(_,conf_int, on = 'variable' )
        )
        
model.summary2()
```

También podemos ver que tanto impacto tienen las variables en el modelo en las siguientes gráficas, donde se representa el coficiente de regresión para cada variable, junto con su intervalo de confianza y el color representando su `p_value`:

```{python}
#| label: p_values analysis
(
    p_vals
        >> filter(_.coefs.between(0,10000000))
        >> ggplot(aes (x= 'reorder(variable, coefs)', y= 'coefs', color = 'p_val'))
        +  geom_point()
        + geom_errorbar(aes(ymin='min', ymax='max'),width=0.3)
        + scale_color_gradient(low='#B05F43',
                       # mid='#B05F43',
                       high= '#3A3AD5',
                       limits=(0,1),
                       name='p_value')
        +  labs(y= 'Coeficiente', x = '', title = 'Analisís de variables con \ncoeficiente positivo')
    +  coord_flip()
)

(
    p_vals
        >> filter(_.coefs.between(-1000,0))
        >> ggplot(aes (x= 'reorder(variable, coefs)', y= 'coefs', color = 'p_val'))
        +  geom_point()
        + geom_errorbar(aes(ymin='min', ymax='max'),width=0.3)
        + scale_color_gradient(low='#B05F43',
                       # mid='#B05F43',
                       high= '#3A3AD5',
                       limits=(0,1),
                       name='p_value')
        +  labs(y= 'Coeficiente', x = '', title = 'Analisís de variables con \ncoeficiente negativo')
    +  coord_flip()
)
```

Puntos a considerar de las gráficas anteriores:

-   Los coeficientes más grandes suelen pertencer a variables que representan alguna proporción, por lo que no es raro el tamaño de sus coeficientes pues siempre seran multiplicados por un número entre 0 y 1.

-   La mayoría de las variables tiene `p_value` cercano a 0, sin embargo algunos otros tienen valores más altos (los más azules), estos se incluyeron en el modelo ya sea porque ayudan en su performance o porque existen interaciones de estas variables.

### Resutados de test y validación

Finalmente en los resultados se lograron las siguiente métricas

```{python}
#| label: test_resutls_lm
#| output: false
#| code-fold: false
y_pred = pipeline_linreg.predict(ames_x_test) * ames_x_test.Gr_Liv_Area
y_obs = Sale_Price_test
test = pd.DataFrame() >> mutate (Sale_Price = y_obs, Sale_Price_Pred = y_pred)

predictores = transformed_df.shape[1]

metrics_testing = get_metrics(y_pred, y_obs, predictores )

y_pred = pipeline_linreg.predict(ames_x_val)*ames_x_val.Gr_Liv_Area
metrics_val = get_metrics(y_pred,Sale_Price_validation,len(transformed_df.columns))

metrics_testing['Resultados validación'] = metrics_val.values
metrics_testing['Resultados test'] = metrics_testing.Value
resultados = metrics_testing >> select(_.contains('test'),_.contains('val')) 
```

```{python}
#| label: tbl testing results lm
#| output: asis
#| echo: false
resultados.to_html()
```

En cuanto al análisis de los residuos se tienen resultados bastante aceptables, donde los residuos parecen seguir una distribución normal con media 0, y no se ven indicios de heterocedasticidad.

```{python}
#| label: analisis de errores lm
#| fig-keep: all
#| results: hide
y_pred = pipeline_linreg.predict(ames_x_test) * ames_x_test.Gr_Liv_Area
(
    ggplot(aes(x = y_pred, y =y_obs)) +
    geom_point(alpha = 0.6) +
    scale_y_continuous(labels = dollar_format(digits=0, big_mark=',') ) +
    scale_x_continuous(labels = dollar_format(digits=0, big_mark=',') ) +
    geom_abline(color = "red") +
    coord_equal() +
    labs(
      title = "Comparación entre predicción y observación",
      x = "Predicción",
      y = "Observación")+theme_tufte()
)


(
test >>
  select(_.Sale_Price, _.Sale_Price_Pred) >>
  mutate(error = _.Sale_Price - _.Sale_Price_Pred) >>
  ggplot(aes(x = "error")) +
  geom_histogram(color = "white", fill = "black") +
  geom_vline(xintercept = 0, color = "red") +
  scale_x_continuous(labels=dollar_format(big_mark=',', digits=0)) + 
  ylab("Conteos de clase") + xlab("Errores") +
  ggtitle("Distribución de error")+theme_tufte()
)

(
test >>
  select(_.Sale_Price, _.Sale_Price_Pred) >>
  mutate(error = _.Sale_Price - _.Sale_Price_Pred) >>
  ggplot(aes(sample = "error")) +
  geom_qq(alpha = 0.3) + stat_qq_line(color = "red") +
  scale_y_continuous(labels=dollar_format(big_mark=',', digits = 0)) + 
  xlab("Distribución normal") + ylab("Distribución de errores") +
  ggtitle("QQ-Plot") +theme_tufte()
)
```

# Preprocesado Generlaizado

Para los siguientes modelos se utilizaron los mismos transformadores que para la regresión líneal, con algunos ligeros cambios, con estos transformadores se creó un pipeline llamado `get_df`, el cual hace todo el proceso para regresar el DataFrame útil a la hora de ajustar los modelos:

```{python}
#| label: preprocesado
#| code-fold: false
#| code-overflow: scroll
#| results: hide
n_usefull = ['Sale_Type', 'Sale_Condition', 'Pool_QC', 'Pool_Area', 'Yr_Sold']

clean_and_imputers = ColumnTransformer(
    [('not_usefull_variables', 'drop', n_usefull),
     ('Impute_Alley', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 'No_Alley_Access'), ['Alley']),
     ('Impute_Mas_Vnr_Type', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 'None'), ['Mas_Vnr_Type']),
     ('Impute_Mas_Vnr_Area', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 0), ['Mas_Vnr_Area']),
     ('Impute_Lot_Frontage', SimpleImputer(
         missing_values=np.nan,
         strategy='mean'), ['Lot_Frontage']),
     ('Impute_Fireplace_Qu', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 'No_Fireplace'), ['Fireplace_Qu']),
     ('Impute_Electrical', SimpleImputer(
         missing_values=np.nan,
         strategy='most_frequent'),['Electrical']),
     ('Impute_Bsmt_Cat', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 'No_Basement'), make_column_selector(pattern = 'Bsmt',dtype_include = 'object')),
     ('Impute_Bsmt_Numeric', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 0), make_column_selector(pattern = 'Bsmt',dtype_exclude = 'object')),
     ('Impute_Garage', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 'No_Garage'), make_column_selector(pattern = 'Garage',dtype_include = 'object')),
     ('Impute_Garage_numeric', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 0), make_column_selector(pattern = 'Garage',dtype_exclude = 'object')),
     ('Impute_Fence', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 'No_Fence'), ['Fence']),
     ('Impute_Misc_Feature', SimpleImputer(
         missing_values=np.nan,
         strategy='constant', 
         fill_value= 'None'), ['Misc_Feature'])
    ],
    remainder= 'passthrough',
    verbose_feature_names_out = False
).set_output(transform = 'pandas')

clean_ames_x_train= clean_and_imputers.fit_transform(ames_x_train)

cond ={1: 'Poor', 2:'Poor',3:'Poor',4:'Average', 5:'Average',6:'Average', 7:'Good_or_Excellent', 8:'Good_or_Excellent', 9:'Good_or_Excellent', 10 :'Good_or_Excellent'}

feature_eng = ColumnTransformer(
  [('collapse_cond',  FunctionTransformer(
                                 collapse,
                                 feature_names_out = None,
                                 kw_args={'c1': 'Overall_Cond', 'dic' : cond }
                                 ), ['Overall_Cond']),
  ('collapse_cond2',  FunctionTransformer(
                                 collapse,
                                 feature_names_out = None,
                                 kw_args={'c1': 'Overall_Qual', 'dic' : cond }
                                 ), ['Overall_Qual']),
  ('Area_Per_Room',  FunctionTransformer(
                                 div_columns,
                                 feature_names_out = None,
                                 kw_args={'c1': 'TotRms_AbvGrd', 'c2': 'Gr_Liv_Area', 'feature_name' : 'Area_Per_Room'}
                                 ), ['TotRms_AbvGrd', 'Gr_Liv_Area']),
    ('Wood_propGLA',  FunctionTransformer(
                                 div_columns,
                                 feature_names_out = None,
                                 kw_args={'c1': 'Wood_Deck_SF', 'c2': 'Gr_Liv_Area', 'feature_name' : 'Wood_propGLA'}
                                 ), ['Wood_Deck_SF', 'Gr_Liv_Area']),
    ('MVNRA_prop',  FunctionTransformer(
                                 div_columns,
                                 feature_names_out = None,
                                 kw_args={'c1': 'Mas_Vnr_Area', 'c2': 'Lot_Area', 'feature_name' : 'MVNRA_propLA'}
                                 ), ['Mas_Vnr_Area', 'Lot_Area']),
    ('2nd_Flr_SF_propGLA',  FunctionTransformer(
                                 div_columns,
                                 feature_names_out = None,
                                 kw_args={'c1': '2nd_Flr_SF', 'c2': 'Gr_Liv_Area', 'feature_name' : '2nd_Flr_SF_propGLA'}
                                 ), ['2nd_Flr_SF', 'Gr_Liv_Area']),
    ('Bsmt_Prop',  FunctionTransformer(
                                 div_columns,
                                 feature_names_out = None,
                                 kw_args={'c1': 'Total_Bsmt_SF', 'c2': 'Gr_Liv_Area', 'feature_name' : 'Bsmt_Prop'}
                                 ),['Total_Bsmt_SF', 'Gr_Liv_Area'] ),
    ('Time_var',  FunctionTransformer(
                                 antique_func,
                                 feature_names_out = None,
                                 kw_args={'yb': 'Year_Built', 'yr': 'Year_Remod/Add'}
                                 ), ['Year_Built', 'Year_Remod/Add']),
    ('Gr_Liv_Area / Loot_Area',  FunctionTransformer(
                                 div_columns,
                                 feature_names_out = None,
                                 kw_args={'c1': 'Gr_Liv_Area', 'c2': 'Lot_Area', 'feature_name' : 'Gr_Liv_A/Loot_A'}
                                 ),['Gr_Liv_Area', 'Lot_Area'] ),
    ('Garage_Prop_overGLA',  FunctionTransformer(
                                 div_columns,
                                 feature_names_out = None,
                                 kw_args={'c1': 'Garage_Area', 'c2': 'Gr_Liv_Area', 'feature_name' : 'Garage_Prop_overGLA'}
                                 ),['Garage_Area', 'Gr_Liv_Area'] ),
    ('1s_Floor_prop',  FunctionTransformer(
                                 div_columns,
                                 feature_names_out = None,
                                 kw_args={'c1': '1st_Flr_SF', 'c2': 'Gr_Liv_Area', 'feature_name' : '1s_Floor_prop'}
                                 ),['1st_Flr_SF', 'Gr_Liv_Area'] ),
    ('just_select', 'passthrough', ['Total_Bsmt_SF','2nd_Flr_SF', 'TotRms_AbvGrd', '1st_Flr_SF', 'Year_Built', 'Year_Remod/Add', 'Garage_Area', 'Lot_Area', 'Gr_Liv_Area', 'Mas_Vnr_Area','Wood_Deck_SF' ])],
    verbose_feature_names_out = False,
    remainder = 'passthrough').set_output(transform = 'pandas')


feature_eng_df = feature_eng.fit_transform(clean_ames_x_train)
my_features = (feature_eng_df>> select (_.contains('_c_'))).columns.to_list()

preprocessor_1 = ColumnTransformer(
    transformers = [
        ('scaler', StandardScaler(), make_column_selector(dtype_exclude  = 'object')),
        # ('just_select', 'passthrough', my_features ),
        ('OHE', OneHotEncoder(drop='first',handle_unknown='infrequent_if_exist' , sparse_output=False, min_frequency = 12), make_column_selector(dtype_include  = 'object'))],
    verbose_feature_names_out = False,
    remainder = 'drop').set_output(transform = 'pandas')

interactions = ColumnTransformer(
  [('Garage_interaction', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': 'Garage_Prop_overGLA_c_', 'cat': 'Garage_Qual', 'return_inputs':'both'}
                                 ), make_column_selector ('Garage_Qual|Garage_Prop_overGLA_c_')),
  ('inter_kitchen', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': 'Kitchen_AbvGr', 'cat': 'Kitchen_Qual', 'return_inputs':'both'}
                                 ), make_column_selector ('Kitchen_Qual|Kitchen_AbvGr')),
  ('Last_remod_c_', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': 'Gr_Liv_A/Loot_A_c_', 'cat': 'Gr_Liv_A/Loot_A_c_', 'return_inputs':'num'}
                                 ), make_column_selector ('Gr_Liv_A/Loot_A_c_')),
  ('1s_Floor_prop_c_|Overall_Q', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': '1s_Floor_prop_c_', 'cat': 'Overall_Q', 'return_inputs':'both'}
                                 ), make_column_selector ('1s_Floor_prop_c_|Overall_Q')),
  ('Bsmt_Qual|Bsmt_Prop_c_', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': 'Bsmt_Prop_c_', 'cat': 'Bsmt_Qual', 'return_inputs':'both'}
                                 ), make_column_selector ('Bsmt_Qual|Bsmt_Prop_c_')),
  ('Area_Per_Room_c_|Overall', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': '2nd_Flr_SF_propGLA_c_', 'cat': 'Antique', 'return_inputs':'both'}
                                 ), make_column_selector ('2nd_Flr_SF_propGLA_c_|Antique')),
  ('MVNRA_propGLA_c_|Mas_Vnr_Type', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': 'MVNRA_propLA_c_', 'cat': 'Mas_Vnr_Type', 'return_inputs':'both'}
                                 ), make_column_selector ('MVNRA_propLA_c_|Mas_Vnr_Type')),
  ('Wood_propGLA_c_|Fireplaces', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': 'Wood_propGLA_c_', 'cat': 'Fireplaces', 'return_inputs':'both'}
                                 ), make_column_selector ('Wood_propGLA_c_|Fireplaces')),
  ('Gr_Liv_Area_x_Neighborhood', FunctionTransformer(
                                 cross_interactions, feature_names_out = None,
                                 kw_args={'num': 'Gr_Liv_Area', 'cat': 'Neighborhood', 'return_inputs':'both'}
                                 ), make_column_selector ('Gr_Liv_Area|Neighborhood')),
  ('TO_DROP_', 'drop', make_column_selector('No_Basement|No_Garage|Exterior|Land|Fence')) ],
  verbose_feature_names_out = False,
  remainder='passthrough').set_output(transform = 'pandas')
  
  
get_df = Pipeline([ 
  ('clean_data', clean_and_imputers),
  ('feat_eng', feature_eng),
  ('preprocessor', preprocessor_1),
  ('interactions', interactions)])
  
get_df.fit(ames_x_train)
```

# KNN model

Se opta por empezar con unmodelo de KNN con todas las variables, esté modelo tiene las siguientes características:

-   El modelo incluye las variables creadas para regresión lineal.

-   Se estandarizaron todas las variables númericas.

-   El One Hot Encoding mantiene una minima frecuencia de 12 elementos por categoría.

Posterior al ajuste de este modelo se busco optimizarlo removiendo variables y probando diferentes comibianciones de estás teniendo como critero la importancia calculada.

## Cross-validation

```{python}
#| label: Libraries KNN
#| code-fold: false
#| results: hide
from sklearn.neighbors import KNeighborsRegressor
from sklearn.model_selection import train_test_split, KFold, cross_val_score, cross_validate
from sklearn.model_selection import GridSearchCV

transformed_df =get_df.transform(ames_x_train)
transformed_test = get_df.transform(ames_x_test)
```

A continuación se hace la validación cruzada para encontrar el mejor hiper-parámetro para el full model:

```{python}
#| eval: false
#| label: KNN CV code
#| code-fold: false 
k = 10
kf = KFold(n_splits=k, shuffle=True, random_state=42)

param_grid = {
 'n_neighbors': range(3, 60 ,2),
 'weights': ['uniform', 'distance'],
 'metric': ['euclidean', 'manhattan','haversine', 'cosine', 'correlation', 'mahalanobis','minkowski'],
 'p' : [5,15,20]
}

scoring = {
    'neg_mean_squared_error': make_scorer(mean_squared_error, greater_is_better=False),
    'r2': make_scorer(adjusted_r2_score, greater_is_better=True, n=np.ceil(len(ames_x_train)), p=transformed_df.shape[1]),
    'neg_mean_absolute_error': make_scorer(mean_absolute_error, greater_is_better=False),
    'mape': make_scorer(mean_absolute_percentage_error, greater_is_better=False)
}


pipeline_knn_cv = Pipeline([
  ('clean_data', clean_and_imputers),
  ('feat_eng', feature_eng),
  ('preprocessor', preprocessor_1),
  ('interactions', interactions),
  ('regressor', GridSearchCV(
      KNeighborsRegressor(),
      param_grid,
      cv=kf,
      scoring=scoring,
      refit='neg_mean_squared_error',
      verbose=3,
      n_jobs=7)
     )]
)
pd.set_option('display.max_columns', 500)
pipeline_knn_cv.fit(ames_x_train, ames_y_train)

```

Tenemos mejores resultados con $K=3$ y distancia de `manhattan`, con ponderación `distance`.

```{python}
#| label: read CV results KNN
#| code-fold: false
#| output: false
#| fig-keep: all
results_cv_trans = pd.read_pickle('..\model/knn/cv_trans_sp.pkl')
results_df_trans = pd.DataFrame(results_cv_trans.cv_results_)

summary_cv_t = (results_df_trans >>select(-_.contains("split"), -_.contains("time"), -_.params))

check_cv(summary_cv_t, param_p=False)
```

Para poder mejorar el modelo se hizo un bucle en el cual en cada iteración se eliminaban las 5 variables con menor importancia, posterior a su remoción se recalcula la importancia de las variables y se repite el proceso, dentro de los bucles se ajusta el modelo $p-i\cdot 5$ veces eliminando las variables por orden de importanca hasta quedarse con una variable y calculando sus métricas, variables usadas y número de variables, se guardan todos los modelos que obtienen una $R^2_{adj} > 0.7$.

```{python}
#| eval: false
#| label: iteraciones drop variables KNN
#| code-fold: false
predictores = transformed_test.columns.shape[0]
best_mods = []
score_mse =[]
score_r = []
for k in range (0,185,5):
  t= 207-k
  if k == 0:
    sc = transformed_df.columns.to_list()
  else: 
    sc = (results >> filter (_.P==t) >> pull ('used_vars'))[0]

  knn_reg.fit(transformed_df[sc], Sale_Price_train)
  metrics = get_metrics(knn_reg.predict(transformed_test[sc]), Sale_Price_test, len(sc))
  importance_df = importance_from_model(
    test_frame = transformed_test,
    y_obs = Sale_Price_test ,
    selected_columns =  sc, 
    pipeline = knn_reg,
    actual_mse = metrics.loc['MSE'].values[0] ,
    n_permutations= 50,
    trans_pred= False
  )
  
  vars_importance_order = list( importance_df >> arrange(_.Mean_Loss) >> pull('Variable'))
  transformed_df =get_df.transform(ames_x_train)
  
  v=[]
  r2=[]
  mse_=[]
  p=[]
  for i in range(t):
    vars_to_train = vars_importance_order[i:]
    p.append(len(vars_to_train))
    knn_reg.fit(transformed_df[vars_to_train], Sale_Price_train)
    pred= knn_reg.predict(transformed_test[vars_to_train])
    mse_.append(get_metrics(pred,Sale_Price_test, len(vars_to_train)).loc['MSE'].values[0])
    r2.append(get_metrics(pred,Sale_Price_test, len(vars_to_train)).loc['R2Adj'].values[0])
    v.append(vars_to_train)
    
  results = pd.DataFrame() >> mutate(MSE = mse_, P=p,R2=r2,used_vars = v)
  best_mods.append( (results >> filter (_.R2>0.7) >> pull ('used_vars')) )
  score_r.append( (results >> filter (_.R2>0.7) >> pull ('R2')) )
  score_mse.append( (results >> filter (_.R2>0.7) >> pull ('MSE')) )


scoresr =  [item for sub_list in score_r for item in sub_list]
scoresmse=  [item for sub_list in score_mse for item in sub_list]
best_mods_ = [item for sub_list in best_mods for item in sub_list] 
num_pred = [len(l) for l in best_mods_]


results_knn_model_iterations = pd.DataFrame() >> mutate (used_vars = best_mods_, r2 = scoresr ,mse = scoresmse, p= num_pred) 
# results_knn_model_iterations.to_csv('data/knn_mod_it.csv')
```

A continuación se muestran los resultados de los modelos salvados durante el bucle, podemos ver que los mejores modelos tienen entre 30 y 60 predictores, estos tienen tanto un $MSE$ bajo como una mayor $R^2_{adj}$.

```{python}
#| label: iter_graficas_knn
#| results: hide
#| fig-keep: all

results_knn_model_iterations = pd.read_csv ('../model/knn/interations_results_knn.csv')
(
  results_knn_model_iterations
    >> ggplot (aes(x='p', y= 'r2' ,color= 'mse'))
    +  geom_point(alpha = 0.6)
    +  labs (x= 'Número de predictores', y= 'R^2', color = 'MSE', title = 'Resultados de iteraciónes con dif.\ncombinaciones de predictores')
)

(
  results_knn_model_iterations >> filter (_.r2>0.85)
    >> ggplot (aes(x='p', y= 'r2' ,color= 'mse'))
    +  geom_point(alpha = 0.6)
    +  labs (x= 'Número de predictores', y= 'R^2', color = 'MSE', title = 'Resultados de iteraciónes con dif. \ncombinaciones de predictores')
)
```

```{python}
#| label: tbl iter knn
#| echo: false
#| output: asis
top = (results_knn_model_iterations 
            >> top_n(20, _.r2) 
            >> arrange (_.p) 
            >> select(  _['$R^2_{adj}$']==_.r2,
                        _['$MSE$'] == -_.mse,
                        _.Predictores == _.p))
top.to_html()
#results_knn_model_iterations.loc[3450].used_vars
```

```{python}
#| label: var selection knn
#| code-fold: false
#| code-overflow: scroll
selected_vars = ['MS_Zoning_RL', 'Bsmt_Qual_Gd', 'Condition_1_infrequent_sklearn', 'Bsmt_Qual_TA', 'Condition_1_Norm', 'Enclosed_Porch', 'Alley_No_Alley_Access', 'Bsmt_Qual_Gd_x_Bsmt_Prop_c_', 'Central_Air_Y', 'House_Style_1Story', 'Kitchen_Qual_TA', 'Lot_Config_Inside', 'Neighborhood_Crawfor_x_Gr_Liv_Area', 'Full_Bath', 'Garage_Finish_RFn', 'Garage_Cars', 'Overall_Qual_Good_or_Excellent', 'Kitchen_Qual_Gd', 'Neighborhood_NoRidge_x_Gr_Liv_Area', 'Antique_c_', 'Garage_Area', 'Gr_Liv_A/Loot_A_c__x_Gr_Liv_A/Loot_A_c_', 'Year_Built', 'Neighborhood_NridgHt_x_Gr_Liv_Area', 'TotRms_AbvGrd', 'Bedroom_AbvGr', 'Lot_Area', 'Area_Per_Room_c_', '2nd_Flr_SF', 'Fireplaces', 'Exter_Qual_Gd', 'Total_Bsmt_SF', '1st_Flr_SF', 'Gr_Liv_Area']

step_select =ColumnTransformer(
  [('selector', 'passthrough', selected_vars )],
  verbose_feature_names_out = False,
  remainder='drop').set_output(transform = 'pandas')

knn_reg = KNeighborsRegressor(
    n_neighbors = 4 ,
    metric = 'manhattan',
    weights = 'distance')
    
knn_regressor = Pipeline([
  ('feat_eng', get_df),
  ('feature_selection', step_select),
  ('regressor', knn_reg)
    ])

knn_regressor.fit(ames_x_train, Sale_Price_train)
```

## Resultados del mejor modelo

Podemos ver que las métricas que se obtienen en los conjuntos de validación y testing, a comparación del modelo de regresión líneal nuestra estimación se aleja más del valor de testing en todas las métricas, aunado a que el modelo tiene únicamente 34 variables y el número de vecinos cercanos es bajo puede que el modelo sea demasiado flexible.

```{python}
#| label: results_knn
#| code-fold: false
#| results: hide
y_pred = knn_regressor.predict(ames_x_test)
y_obs = Sale_Price_test

test_r = get_metrics(y_pred, y_obs, len(selected_vars))

val_r = get_metrics( knn_regressor.predict(ames_x_val), Sale_Price_validation, len(selected_vars))
test_r['vr'] = val_r.values

results = test_r.rename(columns = {'vr': 'Resultados Validación', 'Value':'Resultados test'})
```

```{python}
#| label: tbl_results_knn
#| output: asis
#| echo: false
results.to_html()
```

## Importancia de las variables

A diferencia de la regresión líneal, KNN tiende a darle más importancia a variables relacionadas al área en lugar de proporciones, además el modelo tiene menos de la mitad de variables que el modelo líneal, entre las variables más importantes encontramos los pies cuadrados del primer piso, los pies cuadrados totales del sótano y el área habitable así como variables relacionadas a la edad de la casa como el año de construcción y su antigüedad.

```{python}
#| label: final importance knn
#| eval: false
#| code-fold: false
importance_final_knn  = importance_from_model(
    test_frame = step_select.transform(transformed_test),
    y_obs = Sale_Price_test ,
    selected_columns =  selected_vars, 
    pipeline = knn_reg,
    actual_mse = results['Resultados test'].MSE ,
    n_permutations= 50,
    trans_pred= False
  )
```

```{python}
importance_final_knn = pd.read_csv('../model/knn/importance_final.csv')
(
  importance_final_knn >>
  mutate(
    ymin = _.Mean_Loss - _.Std_Loss,
    ymax = _.Mean_Loss + _.Std_Loss) >>
  ggplot(aes(x = 'reorder(Variable, Mean_Loss)', y = "Mean_Loss")) +
  geom_errorbar(aes(ymin='ymin', ymax='ymax'),
    width=0.2, position=position_dodge(0.9)) +
  geom_point(alpha = 0.65) +
  labs(title='Importancia de las Variables', x='Variable', y='Importancia') +
  coord_flip() +theme_minimal()
)
```
